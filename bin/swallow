#!/usr/bin/env bash
# dwm swallowing for bspwm

main(){
	get_defaults
	listen
}

listen(){
	while IFS=' ' read -r -a node_event; do
		setup_hide_before
		define_elements "${node_event[@]}"
		case_event "${node_event[0]}"
	done < <(bspc subscribe node_add node_remove)
}

define_elements(){ IFS=' '
	desktop=$3
	last_node=$4
	new_node=$5
}

case_event(){
	case $1 in
		node_add) swallow ;;
		node_remove) spit ;;
	esac
}

swallow() {
	query_desktop || return 1
	query_swallower || return 1
	query_swallowing || return 1
	hide_node
}

query_desktop(){
	new_node_desktop=$(bspc query -D -n "$new_node")
	[[ "$desktop" = "$new_node_desktop" ]] || false
}

query_swallower(){
	application=$(probe "$new_node")
	[[ "${application,,}" =~ ${apps,,} ]] || false
}

query_swallowing(){
	terminal=$(probe "$last_node")
	[[ "${terminal,,}" =~ ${terms,,} ]] || false
}

probe(){
	while read -r line; do
		[[ $line =~ WM_CLASS ]] || continue
		: ${line%\"*}; printf '%s' "${_##\"}"
	done < <(xprop -id "$1")
}

hide_node(){
	bspc node "$last_node" -g hidden=on
	bspc node "$new_node" -g hidden=off -f
	swallowed+=("$new_node $last_node")
}

spit() {
	query_spitting || return 1
	query_spitting_desktop || pull_node_desktop
	show_node
}

query_spitting(){
	for ((spit=0;spit<${#swallowed[@]};spit++)); do
		[[ "${swallowed[spit]}" =~ ^$last_node ]] || continue
		set ${swallowed[spit]}; node_spit="$2"
		return 0
	done
	false
}

query_spitting_desktop(){
	spitting_desktop=$(bspc query -D -n "$node_spit")
	[[ "$desktop" = "$spitting_desktop" ]] || false
}

pull_node_desktop(){
	bspc node "$node_spit" -d "$desktop"
}

show_node(){
	bspc node "$node_spit" -g hidden=off -f
	unset 'swallowed[spit]'
	#(:;:);
	bspc node @/ -R 90
}

get_defaults(){
	terms="${SWALLOW_TERMINALS:-st|urxvt|kitty}"
	from_xdg="$(get_from_xdg)"
	apps="${SWALLOW_APPLICATIONS:-$from_xdg}"
}

setup_hide_before(){
	IFS='|' read -rd '' -a hide_before <<<$apps
	for app in Sxiv "${hide_before[@]}"; do
		bspc rule -a $app --one-shot hidden=on
		echo "set rules for $app"
	done
}

get_from_xdg(){
	for app in "image/*" "video/*" "application/pdf"; do
		: "$(xdg-mime query default $app)"
		xdg_apps+="${_%.desktop}|"
	done
	printf '%s\n' "${xdg_apps%|}"
}

survive_restart(){
	trap 'write_survival || rm $survival' EXIT
	survival="${TMPDIR:-/tmp}/swallowed"
	read_survival
}

write_survival(){
	[[ ${swallowed[@]} ]] || return 1
	printf '%s\n' "${swallowed[@]}" > "$survival"
}

read_survival(){
	[[ -a "$survival" ]] || return 1
	IFS=$'\n' read -rd '' -a swallowed < "$survival"
}

survive_restart
main
